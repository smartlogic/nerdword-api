#!/usr/bin/env ruby
require File.expand_path('../../config/environment',  __FILE__)
require 'capybara/server'
require 'forwardable'

Capybara.server do |app, port|
  require 'rack/handler/thin'
  Thin::Logging.silent = true
  Rack::Handler::Thin.run(app, :Port => port)
end

server = Capybara::Server.new(Rails.application, 8888)
server.boot

class Client
  extend Forwardable

  def_delegators :connection, :basic_auth, :get, :post, :put, :delete

  def connection
    @connection ||= Faraday.new(:url => "http://localhost:8888") do |faraday|
      faraday.request :url_encoded
      faraday.use JsonMiddleware
      faraday.adapter Faraday.default_adapter
    end
  end

  class JsonMiddleware < Faraday::Middleware
    def call(env)
      env[:request_headers]["Accept"] = "application/json"
      env[:request_headers]["Content-Type"] = "application/json"

      @app.call(env)
    end
  end
end

class Resource
  def self.load(string)
    new(JSON.load(string))
  end
end

class Links
  def initialize(link_hash)
    @links = link_hash
  end

  # Fetch out links not worrying about custom rels
  #
  # @param [String] link relation
  #
  # @return [String] href
  def fetch(link)
    link = CoreRels.rel(link) if !@links.has_key?(link)
    @links.fetch(link, {}).fetch("href", "")
  end

  # Check if a link rel is included
  #
  # @param [String] link relation
  #
  # @return [Boolean]
  def has_link?(link)
    @links.has_key?(link) || @links.has_key?(CoreRels.rel(link))
  end
end

class RootResource < Resource
  attr_accessor :links

  def initialize(attrs)
    @links = Links.new(attrs.fetch("_links"))
  end
end

class GamesResource < Resource
  attr_accessor :games

  def initialize(attrs)
    @games = attrs.fetch("_embedded", {}).fetch("games", []).map { |game_attrs| GameResource.new(game_attrs) }
    @links = Links.new(attrs.fetch("_links"))
  end
end

class GameResource < Resource
  attr_accessor :users

  def initialize(attrs)
    @users = attrs.fetch("_embedded", {}).fetch("users", []).map { |user_attrs| UserResource.new(user_attrs) }
    @links = Links.new(attrs.fetch("_links"))
  end
end

class UserResource < Resource
  attr_accessor :email

  def initialize(attrs)
    @email = attrs.fetch("email")
  end
end

puts "Server booted"

player_1_email = "player-#{SecureRandom.hex(10)}@example.com"
player_2_email = "player-#{SecureRandom.hex(10)}@example.com"
password = "password"


# Create player
player_1_client = Client.new
root_resource = RootResource.load(player_1_client.get("/").body)
user_registration_url = root_resource.links.fetch("user-registration")

player_1_client.post(user_registration_url, { :user => { :email => player_1_email, :password => password } }.to_json)
player_1_client.basic_auth(player_1_email, password)


# Create player
player_2_client = Client.new
root_resource = RootResource.load(player_2_client.get("/").body)
user_registration_url = root_resource.links.fetch("user-registration")

player_2_client.post(user_registration_url, { :user => { :email => player_2_email, :password => password } }.to_json)
player_2_client.basic_auth(player_2_email, password)


# Create the game
root_resource = RootResource.load(player_1_client.get("/").body)
games_link = root_resource.links.fetch("games")
player_1_client.post(games_link, { :players => [player_2_email] }.to_json)


# View the game
root_resource = RootResource.load(player_1_client.get("/").body)
games_link = root_resource.links.fetch("games")
games_resource = GamesResource.load(player_1_client.get(games_link).body)

puts "Player 1 has #{games_resource.games.count} games"
games_resource.games.each do |game|
  puts
  game.users.each do |user|
    puts "* #{user.email}"
  end
  puts
end

# View the game
root_resource = RootResource.load(player_2_client.get("/").body)
games_link = root_resource.links.fetch("games")
games_resource = GamesResource.load(player_2_client.get(games_link).body)

puts "Player 2 has #{games_resource.games.count} games"
games_resource.games.each do |game|
  puts
  game.users.each do |user|
    puts "* #{user.email}"
  end
  puts
end
